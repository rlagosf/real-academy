{"ast":null,"code":"import WatchPrimitiveProperties from '../utils/WatchPrimitiveProperties';\nimport { Str } from \"./string\";\nexport function getPropsValues(vueInst, props) {\n  return Object.keys(props).reduce((acc, prop) => {\n    if (vueInst[prop] !== undefined) {\n      acc[prop] = vueInst[prop];\n    }\n    return acc;\n  }, {});\n}\n\n/**\r\n * Binds the properties defined in props to the google maps instance.\r\n * If the prop is an Object type, and we wish to track the properties\r\n * of the object (e.g. the lat and lng of a LatLng), then we do a deep\r\n * watch. For deep watch, we also prevent the _changed event from being\r\n * $emitted if the data source was external.\r\n */\nexport function bindProps(vueInst, googleMapsInst, props) {\n  for (let attribute in props) {\n    let {\n      twoWay,\n      type,\n      trackProperties,\n      noBind\n    } = props[attribute];\n    if (noBind) continue;\n    const setMethodName = 'set' + Str.capitalizeFirstLetter(attribute);\n    const getMethodName = 'get' + Str.capitalizeFirstLetter(attribute);\n    const eventName = attribute.toLowerCase() + '_changed';\n    const initialValue = vueInst[attribute];\n    if (typeof googleMapsInst[setMethodName] === 'undefined') {\n      throw new Error(`${setMethodName} is not a method of (the Maps object corresponding to) ${vueInst.$options._componentTag}`);\n    }\n\n    // We need to avoid an endless\n    // propChanged -> event $emitted -> propChanged -> event $emitted loop\n    // although this may really be the user's responsibility\n    if (type !== Object || !trackProperties) {\n      // Track the object deeply\n      vueInst.$watch(attribute, () => {\n        const attributeValue = vueInst[attribute];\n        googleMapsInst[setMethodName](attributeValue);\n      }, {\n        immediate: typeof initialValue !== 'undefined',\n        deep: type === Object\n      });\n    } else {\n      WatchPrimitiveProperties(vueInst, trackProperties.map(prop => `${attribute}.${prop}`), () => {\n        googleMapsInst[setMethodName](vueInst[attribute]);\n      }, vueInst[attribute] !== undefined);\n    }\n    if (twoWay && (vueInst.$gmapOptions.autobindAllEvents || vueInst.$attrs[eventName])) {\n      googleMapsInst.addListener(eventName, () => {\n        // eslint-disable-line no-unused-vars\n        vueInst.$emit(eventName, googleMapsInst[getMethodName]());\n      });\n    }\n  }\n}","map":{"version":3,"names":["WatchPrimitiveProperties","Str","getPropsValues","vueInst","props","Object","keys","reduce","acc","prop","undefined","bindProps","googleMapsInst","attribute","twoWay","type","trackProperties","noBind","setMethodName","capitalizeFirstLetter","getMethodName","eventName","toLowerCase","initialValue","Error","$options","_componentTag","$watch","attributeValue","immediate","deep","map","$gmapOptions","autobindAllEvents","$attrs","addListener","$emit"],"sources":["C:/Users/DIVDOC-INTERNET/Desktop/real-academy/real-academy-frontend/node_modules/@fawmi/vue-google-maps/src/utils/bindProps.js"],"sourcesContent":["import WatchPrimitiveProperties from '../utils/WatchPrimitiveProperties'\r\nimport {Str} from \"./string\";\r\n\r\nexport function getPropsValues(vueInst, props) {\r\n  return Object.keys(props).reduce((acc, prop) => {\r\n    if (vueInst[prop] !== undefined) {\r\n      acc[prop] = vueInst[prop]\r\n    }\r\n    return acc\r\n  }, {})\r\n}\r\n\r\n/**\r\n * Binds the properties defined in props to the google maps instance.\r\n * If the prop is an Object type, and we wish to track the properties\r\n * of the object (e.g. the lat and lng of a LatLng), then we do a deep\r\n * watch. For deep watch, we also prevent the _changed event from being\r\n * $emitted if the data source was external.\r\n */\r\nexport function bindProps(vueInst, googleMapsInst, props) {\r\n  for (let attribute in props) {\r\n    let { twoWay, type, trackProperties, noBind } = props[attribute]\r\n\r\n    if (noBind) continue\r\n\r\n    const setMethodName = 'set' + Str.capitalizeFirstLetter(attribute)\r\n    const getMethodName = 'get' + Str.capitalizeFirstLetter(attribute)\r\n    const eventName = attribute.toLowerCase() + '_changed'\r\n    const initialValue = vueInst[attribute]\r\n\r\n    if (typeof googleMapsInst[setMethodName] === 'undefined') {\r\n      throw new Error(\r\n        `${setMethodName} is not a method of (the Maps object corresponding to) ${vueInst.$options._componentTag}`\r\n      )\r\n    }\r\n\r\n    // We need to avoid an endless\r\n    // propChanged -> event $emitted -> propChanged -> event $emitted loop\r\n    // although this may really be the user's responsibility\r\n    if (type !== Object || !trackProperties) {\r\n      // Track the object deeply\r\n      vueInst.$watch(attribute,\r\n        () => {\r\n          const attributeValue = vueInst[attribute]\r\n\r\n          googleMapsInst[setMethodName](attributeValue)\r\n        },\r\n        {\r\n          immediate: typeof initialValue !== 'undefined',\r\n          deep: type === Object,\r\n        }\r\n      )\r\n    } else {\r\n      WatchPrimitiveProperties(\r\n        vueInst,\r\n        trackProperties.map((prop) => `${attribute}.${prop}`),\r\n        () => {\r\n          googleMapsInst[setMethodName](vueInst[attribute])\r\n        },\r\n        vueInst[attribute] !== undefined\r\n      )\r\n    }\r\n\r\n    if (twoWay && (vueInst.$gmapOptions.autobindAllEvents || vueInst.$attrs[eventName])) {\r\n      googleMapsInst.addListener(eventName, () => {\r\n        // eslint-disable-line no-unused-vars\r\n        vueInst.$emit(eventName, googleMapsInst[getMethodName]())\r\n      })\r\n    }\r\n  }\r\n}\r\n"],"mappings":"AAAA,OAAOA,wBAAwB,MAAM,mCAAmC;AACxE,SAAQC,GAAG,QAAO,UAAU;AAE5B,OAAO,SAASC,cAAcA,CAACC,OAAO,EAAEC,KAAK,EAAE;EAC7C,OAAOC,MAAM,CAACC,IAAI,CAACF,KAAK,CAAC,CAACG,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAK;IAC9C,IAAIN,OAAO,CAACM,IAAI,CAAC,KAAKC,SAAS,EAAE;MAC/BF,GAAG,CAACC,IAAI,CAAC,GAAGN,OAAO,CAACM,IAAI,CAAC;IAC3B;IACA,OAAOD,GAAG;EACZ,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,SAASA,CAACR,OAAO,EAAES,cAAc,EAAER,KAAK,EAAE;EACxD,KAAK,IAAIS,SAAS,IAAIT,KAAK,EAAE;IAC3B,IAAI;MAAEU,MAAM;MAAEC,IAAI;MAAEC,eAAe;MAAEC;IAAO,CAAC,GAAGb,KAAK,CAACS,SAAS,CAAC;IAEhE,IAAII,MAAM,EAAE;IAEZ,MAAMC,aAAa,GAAG,KAAK,GAAGjB,GAAG,CAACkB,qBAAqB,CAACN,SAAS,CAAC;IAClE,MAAMO,aAAa,GAAG,KAAK,GAAGnB,GAAG,CAACkB,qBAAqB,CAACN,SAAS,CAAC;IAClE,MAAMQ,SAAS,GAAGR,SAAS,CAACS,WAAW,CAAC,CAAC,GAAG,UAAU;IACtD,MAAMC,YAAY,GAAGpB,OAAO,CAACU,SAAS,CAAC;IAEvC,IAAI,OAAOD,cAAc,CAACM,aAAa,CAAC,KAAK,WAAW,EAAE;MACxD,MAAM,IAAIM,KAAK,CACb,GAAGN,aAAa,0DAA0Df,OAAO,CAACsB,QAAQ,CAACC,aAAa,EAC1G,CAAC;IACH;;IAEA;IACA;IACA;IACA,IAAIX,IAAI,KAAKV,MAAM,IAAI,CAACW,eAAe,EAAE;MACvC;MACAb,OAAO,CAACwB,MAAM,CAACd,SAAS,EACtB,MAAM;QACJ,MAAMe,cAAc,GAAGzB,OAAO,CAACU,SAAS,CAAC;QAEzCD,cAAc,CAACM,aAAa,CAAC,CAACU,cAAc,CAAC;MAC/C,CAAC,EACD;QACEC,SAAS,EAAE,OAAON,YAAY,KAAK,WAAW;QAC9CO,IAAI,EAAEf,IAAI,KAAKV;MACjB,CACF,CAAC;IACH,CAAC,MAAM;MACLL,wBAAwB,CACtBG,OAAO,EACPa,eAAe,CAACe,GAAG,CAAEtB,IAAI,IAAK,GAAGI,SAAS,IAAIJ,IAAI,EAAE,CAAC,EACrD,MAAM;QACJG,cAAc,CAACM,aAAa,CAAC,CAACf,OAAO,CAACU,SAAS,CAAC,CAAC;MACnD,CAAC,EACDV,OAAO,CAACU,SAAS,CAAC,KAAKH,SACzB,CAAC;IACH;IAEA,IAAII,MAAM,KAAKX,OAAO,CAAC6B,YAAY,CAACC,iBAAiB,IAAI9B,OAAO,CAAC+B,MAAM,CAACb,SAAS,CAAC,CAAC,EAAE;MACnFT,cAAc,CAACuB,WAAW,CAACd,SAAS,EAAE,MAAM;QAC1C;QACAlB,OAAO,CAACiC,KAAK,CAACf,SAAS,EAAET,cAAc,CAACQ,aAAa,CAAC,CAAC,CAAC,CAAC;MAC3D,CAAC,CAAC;IACJ;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}