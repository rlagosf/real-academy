{"ast":null,"code":"import bindEvents from '../utils/bindEvents.js';\nimport { bindProps, getPropsValues } from '../utils/bindProps.js';\nimport MapElementMixin from './mapElementMixin';\n\n/**\r\n *\r\n * @param {Object} options\r\n * @param {Object} options.mappedProps - Definitions of props\r\n * @param {Object} options.mappedProps.PROP.type - Value type\r\n * @param {Boolean} options.mappedProps.PROP.twoWay\r\n *  - Whether the prop has a corresponding PROP_changed\r\n *   event\r\n * @param {Boolean} options.mappedProps.PROP.noBind\r\n *  - If true, do not apply the default bindProps / bindEvents.\r\n * However it will still be added to the list of component props\r\n * @param {Object} options.props - Regular Vue-style props.\r\n *  Note: must be in the Object form because it will be\r\n *  merged with the `mappedProps`\r\n *\r\n * @param {Object} options.events - Google Maps API events\r\n *  that are not bound to a corresponding prop\r\n * @param {String} options.name - e.g. `polyline`\r\n * @param {=> String} options.ctr - constructor, e.g.\r\n *  `google.maps.Polyline`. However, since this is not\r\n *  generally available during library load, this becomes\r\n *  a function instead, e.g. () => google.maps.Polyline\r\n *  which will be called only after the API has been loaded\r\n * @param {(MappedProps, OtherVueProps) => Array} options.ctrArgs -\r\n *   If the constructor in `ctr` needs to be called with\r\n *   arguments other than a single `options` object, e.g. for\r\n *   GroundOverlay, we call `new GroundOverlay(url, bounds, options)`\r\n *   then pass in a function that returns the argument list as an array\r\n *\r\n * Otherwise, the constructor will be called with an `options` object,\r\n *   with property and values merged from:\r\n *\r\n *   1. the `options` property, if any\r\n *   2. a `map` property with the Google Maps\r\n *   3. all the properties passed to the component in `mappedProps`\r\n * @param {Object => Any} options.beforeCreate -\r\n *  Hook to modify the options passed to the initializer\r\n * @param {(options.ctr, Object) => Any} options.afterCreate -\r\n *  Hook called when\r\n *\r\n */\nexport default function (options) {\n  const {\n    mappedProps,\n    name,\n    ctr,\n    ctrArgs,\n    events,\n    beforeCreate,\n    afterCreate,\n    props,\n    ...rest\n  } = options;\n  const promiseName = `$${name}Promise`;\n  const instanceName = `$${name}Object`;\n  assert(!(rest.props instanceof Array), '`props` should be an object, not Array');\n  return {\n    ...(typeof GENERATE_DOC !== 'undefined' ? {\n      $vgmOptions: options\n    } : {}),\n    mixins: [MapElementMixin],\n    props: {\n      ...props,\n      ...mappedPropsToVueProps(mappedProps)\n    },\n    render() {\n      return '';\n    },\n    provide() {\n      const promise = this.$mapPromise.then(map => {\n        // Infowindow needs this to be immediately available\n        this.$map = map;\n\n        // Initialize the maps with the given options\n        const options = {\n          ...this.options,\n          map,\n          ...getPropsValues(this, mappedProps)\n        };\n        delete options.options; // delete the extra options\n\n        if (beforeCreate) {\n          const result = beforeCreate.bind(this)(options);\n          if (result instanceof Promise) {\n            return result.then(() => ({\n              options\n            }));\n          }\n        }\n        return {\n          options\n        };\n      }).then(({\n        options\n      }) => {\n        const ConstructorObject = ctr();\n        // https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\n        this[instanceName] = ctrArgs ? new (Function.prototype.bind.call(ConstructorObject, null, ...ctrArgs(options, getPropsValues(this, props || {}))))() : new ConstructorObject(options);\n        bindProps(this, this[instanceName], mappedProps);\n        bindEvents(this, this[instanceName], events);\n        if (afterCreate) {\n          afterCreate.bind(this)(this[instanceName]);\n        }\n        return this[instanceName];\n      });\n      this[promiseName] = promise;\n      return {\n        [promiseName]: promise\n      };\n    },\n    unmounted() {\n      // Note: not all Google Maps components support maps\n      if (this[instanceName] && this[instanceName].setMap) {\n        this[instanceName].setMap(null);\n      }\n    },\n    ...rest\n  };\n}\nfunction assert(v, message) {\n  if (!v) throw new Error(message);\n}\n\n/**\r\n * Strips out the extraneous properties we have in our\r\n * props definitions\r\n * @param {Object} props\r\n */\nexport function mappedPropsToVueProps(mappedProps) {\n  return Object.entries(mappedProps).map(([key, prop]) => {\n    const value = {};\n    if ('type' in prop) value.type = prop.type;\n    if ('default' in prop) value.default = prop.default;\n    if ('required' in prop) value.required = prop.required;\n    return [key, value];\n  }).reduce((acc, [key, val]) => {\n    acc[key] = val;\n    return acc;\n  }, {});\n}","map":{"version":3,"names":["bindEvents","bindProps","getPropsValues","MapElementMixin","options","mappedProps","name","ctr","ctrArgs","events","beforeCreate","afterCreate","props","rest","promiseName","instanceName","assert","Array","GENERATE_DOC","$vgmOptions","mixins","mappedPropsToVueProps","render","provide","promise","$mapPromise","then","map","$map","result","bind","Promise","ConstructorObject","Function","prototype","call","unmounted","setMap","v","message","Error","Object","entries","key","prop","value","type","default","required","reduce","acc","val"],"sources":["C:/Users/DIVDOC-INTERNET/Desktop/real-academy/real-academy-frontend/node_modules/@fawmi/vue-google-maps/src/components/build-component.js"],"sourcesContent":["import bindEvents from '../utils/bindEvents.js'\r\nimport { bindProps, getPropsValues } from '../utils/bindProps.js'\r\nimport MapElementMixin from './mapElementMixin'\r\n\r\n/**\r\n *\r\n * @param {Object} options\r\n * @param {Object} options.mappedProps - Definitions of props\r\n * @param {Object} options.mappedProps.PROP.type - Value type\r\n * @param {Boolean} options.mappedProps.PROP.twoWay\r\n *  - Whether the prop has a corresponding PROP_changed\r\n *   event\r\n * @param {Boolean} options.mappedProps.PROP.noBind\r\n *  - If true, do not apply the default bindProps / bindEvents.\r\n * However it will still be added to the list of component props\r\n * @param {Object} options.props - Regular Vue-style props.\r\n *  Note: must be in the Object form because it will be\r\n *  merged with the `mappedProps`\r\n *\r\n * @param {Object} options.events - Google Maps API events\r\n *  that are not bound to a corresponding prop\r\n * @param {String} options.name - e.g. `polyline`\r\n * @param {=> String} options.ctr - constructor, e.g.\r\n *  `google.maps.Polyline`. However, since this is not\r\n *  generally available during library load, this becomes\r\n *  a function instead, e.g. () => google.maps.Polyline\r\n *  which will be called only after the API has been loaded\r\n * @param {(MappedProps, OtherVueProps) => Array} options.ctrArgs -\r\n *   If the constructor in `ctr` needs to be called with\r\n *   arguments other than a single `options` object, e.g. for\r\n *   GroundOverlay, we call `new GroundOverlay(url, bounds, options)`\r\n *   then pass in a function that returns the argument list as an array\r\n *\r\n * Otherwise, the constructor will be called with an `options` object,\r\n *   with property and values merged from:\r\n *\r\n *   1. the `options` property, if any\r\n *   2. a `map` property with the Google Maps\r\n *   3. all the properties passed to the component in `mappedProps`\r\n * @param {Object => Any} options.beforeCreate -\r\n *  Hook to modify the options passed to the initializer\r\n * @param {(options.ctr, Object) => Any} options.afterCreate -\r\n *  Hook called when\r\n *\r\n */\r\nexport default function (options) {\r\n  const {\r\n    mappedProps,\r\n    name,\r\n    ctr,\r\n    ctrArgs,\r\n    events,\r\n    beforeCreate,\r\n    afterCreate,\r\n    props,\r\n    ...rest\r\n  } = options\r\n\r\n  const promiseName = `$${name}Promise`\r\n  const instanceName = `$${name}Object`\r\n\r\n  assert(!(rest.props instanceof Array), '`props` should be an object, not Array')\r\n\r\n  return {\r\n    ...(typeof GENERATE_DOC !== 'undefined' ? { $vgmOptions: options } : {}),\r\n    mixins: [MapElementMixin],\r\n    props: {\r\n      ...props,\r\n      ...mappedPropsToVueProps(mappedProps),\r\n    },\r\n    render() {\r\n      return ''\r\n    },\r\n    provide() {\r\n      const promise = this.$mapPromise\r\n        .then((map) => {\r\n          // Infowindow needs this to be immediately available\r\n          this.$map = map\r\n\r\n          // Initialize the maps with the given options\r\n          const options = {\r\n            ...this.options,\r\n            map,\r\n            ...getPropsValues(this, mappedProps),\r\n          }\r\n          delete options.options // delete the extra options\r\n\r\n          if (beforeCreate) {\r\n            const result = beforeCreate.bind(this)(options)\r\n\r\n            if (result instanceof Promise) {\r\n              return result.then(() => ({ options }))\r\n            }\r\n          }\r\n          return { options }\r\n        })\r\n        .then(({ options }) => {\r\n          const ConstructorObject = ctr()\r\n          // https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\r\n          this[instanceName] = ctrArgs\r\n            ? new (Function.prototype.bind.call(\r\n                ConstructorObject,\r\n                null,\r\n                ...ctrArgs(options, getPropsValues(this, props || {}))\r\n              ))()\r\n            : new ConstructorObject(options)\r\n\r\n          bindProps(this, this[instanceName], mappedProps)\r\n          bindEvents(this, this[instanceName], events)\r\n\r\n          if (afterCreate) {\r\n            afterCreate.bind(this)(this[instanceName])\r\n          }\r\n          return this[instanceName]\r\n        })\r\n      this[promiseName] = promise\r\n      return { [promiseName]: promise }\r\n    },\r\n    unmounted() {\r\n      // Note: not all Google Maps components support maps\r\n      if (this[instanceName] && this[instanceName].setMap) {\r\n        this[instanceName].setMap(null)\r\n      }\r\n    },\r\n    ...rest,\r\n  }\r\n}\r\n\r\nfunction assert(v, message) {\r\n  if (!v) throw new Error(message)\r\n}\r\n\r\n/**\r\n * Strips out the extraneous properties we have in our\r\n * props definitions\r\n * @param {Object} props\r\n */\r\nexport function mappedPropsToVueProps(mappedProps) {\r\n  return Object.entries(mappedProps)\r\n    .map(([key, prop]) => {\r\n      const value = {}\r\n\r\n      if ('type' in prop) value.type = prop.type\r\n      if ('default' in prop) value.default = prop.default\r\n      if ('required' in prop) value.required = prop.required\r\n\r\n      return [key, value]\r\n    })\r\n    .reduce((acc, [key, val]) => {\r\n      acc[key] = val\r\n      return acc\r\n    }, {})\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}