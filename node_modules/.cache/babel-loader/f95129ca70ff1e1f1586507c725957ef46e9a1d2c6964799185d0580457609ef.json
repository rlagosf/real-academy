{"ast":null,"code":"/**\r\n * When you have two-way bindings, but the actual bound value will not equal\r\n * the value you initially passed in, then to avoid an infinite loop you\r\n * need to increment a counter every time you pass in a value, decrement the\r\n * same counter every time the bound value changed, but only bubble up\r\n * the event when the counter is zero.\r\n *\r\nExample:\r\n\r\nLet's say DrawingRecognitionCanvas is a deep-learning backed canvas\r\nthat, when given the name of an object (e.g. 'dog'), draws a dog.\r\nBut whenever the drawing on it changes, it also sends back its interpretation\r\nof the image by way of the @newObjectRecognized event.\r\n\r\n<input\r\n  type=\"text\"\r\n  placeholder=\"an object, e.g. Dog, Cat, Frog\"\r\n  v-model=\"identifiedObject\" />\r\n<DrawingRecognitionCanvas\r\n  :object=\"identifiedObject\"\r\n  @newObjectRecognized=\"identifiedObject = $event\"\r\n  />\r\n\r\nnew TwoWayBindingWrapper((increment, decrement, shouldUpdate) => {\r\n  this.$watch('identifiedObject', () => {\r\n    // new object passed in\r\n    increment()\r\n  })\r\n  this.$deepLearningBackend.on('drawingChanged', () => {\r\n    recognizeObject(this.$deepLearningBackend)\r\n      .then((object) => {\r\n        decrement()\r\n        if (shouldUpdate()) {\r\n          this.$emit('newObjectRecognized', object.name)\r\n        }\r\n      })\r\n  })\r\n})\r\n */\nexport default function TwoWayBindingWrapper(fn) {\n  let counter = 0;\n  fn(() => {\n    counter += 1;\n  }, () => {\n    counter = Math.max(0, counter - 1);\n  }, () => counter === 0);\n}","map":{"version":3,"names":["TwoWayBindingWrapper","fn","counter","Math","max"],"sources":["C:/Users/DIVDOC-INTERNET/Desktop/real-academy/real-academy-frontend/node_modules/@fawmi/vue-google-maps/src/utils/TwoWayBindingWrapper.js"],"sourcesContent":["/**\r\n * When you have two-way bindings, but the actual bound value will not equal\r\n * the value you initially passed in, then to avoid an infinite loop you\r\n * need to increment a counter every time you pass in a value, decrement the\r\n * same counter every time the bound value changed, but only bubble up\r\n * the event when the counter is zero.\r\n *\r\nExample:\r\n\r\nLet's say DrawingRecognitionCanvas is a deep-learning backed canvas\r\nthat, when given the name of an object (e.g. 'dog'), draws a dog.\r\nBut whenever the drawing on it changes, it also sends back its interpretation\r\nof the image by way of the @newObjectRecognized event.\r\n\r\n<input\r\n  type=\"text\"\r\n  placeholder=\"an object, e.g. Dog, Cat, Frog\"\r\n  v-model=\"identifiedObject\" />\r\n<DrawingRecognitionCanvas\r\n  :object=\"identifiedObject\"\r\n  @newObjectRecognized=\"identifiedObject = $event\"\r\n  />\r\n\r\nnew TwoWayBindingWrapper((increment, decrement, shouldUpdate) => {\r\n  this.$watch('identifiedObject', () => {\r\n    // new object passed in\r\n    increment()\r\n  })\r\n  this.$deepLearningBackend.on('drawingChanged', () => {\r\n    recognizeObject(this.$deepLearningBackend)\r\n      .then((object) => {\r\n        decrement()\r\n        if (shouldUpdate()) {\r\n          this.$emit('newObjectRecognized', object.name)\r\n        }\r\n      })\r\n  })\r\n})\r\n */\r\nexport default function TwoWayBindingWrapper(fn) {\r\n  let counter = 0\r\n\r\n  fn(\r\n    () => {\r\n      counter += 1\r\n    },\r\n    () => {\r\n      counter = Math.max(0, counter - 1)\r\n    },\r\n    () => counter === 0\r\n  )\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,oBAAoBA,CAACC,EAAE,EAAE;EAC/C,IAAIC,OAAO,GAAG,CAAC;EAEfD,EAAE,CACA,MAAM;IACJC,OAAO,IAAI,CAAC;EACd,CAAC,EACD,MAAM;IACJA,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEF,OAAO,GAAG,CAAC,CAAC;EACpC,CAAC,EACD,MAAMA,OAAO,KAAK,CACpB,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}